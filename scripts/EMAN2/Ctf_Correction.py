"""
 components/tools/OmeroPy/scripts/EMAN2/Ctf_Correction.py 

-----------------------------------------------------------------------------
  Copyright (C) 2006-2010 University of Dundee. All rights reserved.


  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License along
  with this program; if not, write to the Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

------------------------------------------------------------------------------

This script uses EMAN2 to perform CTF correction on images in OMERO. 
Uses the command line e2ctf.py 
Uploads the resulting CTF-corrected images into a new dataset. 
    
@author  Will Moore &nbsp;&nbsp;&nbsp;&nbsp;
<a href="mailto:will@lifesci.dundee.ac.uk">will@lifesci.dundee.ac.uk</a>
@version 3.0
<small>
(<b>Internal version:</b> $Revision: $Date: $)
</small>
@since 3.0-Beta4.2
 
"""

from EMAN2 import *
import os

import numpy

import Image     # for saving tiff locally. Maybe better to use EMAN2? 

import omero
import omero_api_Gateway_ice    # see http://tinyurl.com/icebuserror
import omero.scripts as scripts
from omero.rtypes import *
import omero.util.script_utils as scriptUtil
#from omero.util.script_utils import *


# keep track of log strings. 
logStrings = []

def log(text):
    """
    Adds the text to a list of logs. Compiled into figure legend at the end.
    """
    #print text
    logStrings.append(text)
    

def uploadBdbsAsDataset(services, bdbContainer, imageIds, project = None, info = None):
    
    """
    This method takes a folder that contains multiple bdbs, each representing different ctf output. 
    This is what is generated by the e2ctf.py command, when it is running on images not in a bdb. 
    Output images (in the form of bdbs) are placed in a 'particles' folder in the current directory.
    This method uploads all the images in the given directory into a new dataset per bdb.  
    
    @param bdbContainer     path to bdb. In this script, it is a relative path (folder name) E.g. 'particles'
    @param imageIds         The OMERO image-ids that these particles come from. Add to descriptions 
    @param project          if specified, put each dataset into this project (omero.model.ProjectI)
    @param info             Extra info to add to dataset description and image descriptions. 
    
    """
    
    gateway = services["gateway"]
    re = services["renderingEngine"]
    queryService = services["queryService"]
    pixelsService = services["pixelsService"]
    rawPixelStore = services["rawPixelsStore"]
    updateService = services["updateService"]
    rawFileStore = services["rawFileStore"]

    # get the list of bdbs
    dbs = db_list_dicts('bdb:%s' % bdbContainer)
    
    print dbs
    if len(dbs) == 0:
        print "No bdb images to upload"
        return
    
    d = EMData()
    # use first image to get data-type (assume all the same!)
    dbpath = "bdb:particles#%s" % dbs[0]
    d.read_image(dbpath, 0)
    plane2D = EMNumPy.em2numpy(d)
    pType = plane2D.dtype.name
    print pType
    pixelsType = queryService.findByQuery("from PixelsType as p where p.value='%s'" % pType, None) # omero::model::PixelsType
    
    if pixelsType == None and pType.startswith("float"):
        # try 'float'
        pixelsType = queryService.findByQuery("from PixelsType as p where p.value='%s'" % "float", None) # omero::model::PixelsType
    if pixelsType == None:
        print "Unknown pixels type for: " % pType
        return
    else:
        print "Using pixels type ", pixelsType.getValue().getValue()
    
    namespace = omero.constants.namespaces.NSCOMPANIONFILE 
    fileName = "original_metadata.txt"
    
    # loop through all the images. 
    
    for db in dbs:
        dbpath = "bdb:particles#%s" % db 
        nimg = EMUtil.get_image_count(dbpath)    # eg images in bdb 'folder'
        print "Found %d images to import from: %s" % (nimg, dbpath)
        
        # make a dataset for images
        dataset = omero.model.DatasetI()
        dataset.name = rstring(db)
        dataset.description = rstring(info)
        dataset = gateway.saveAndReturnObject(dataset)
        if project:        # and put it in a new project
            link = omero.model.ProjectDatasetLinkI()
            link.parent = omero.model.ProjectI(project.id.val, False)
            link.child = omero.model.DatasetI(dataset.id.val, False)
            gateway.saveAndReturnObject(link)
            
        for i in range(nimg):
            newImageName = str(db)
            print "Importing image: %d" % i
            description = "CTF-corrected image\n"
            if info:    description += " %s\n" % info
            description += " Original Image ID: %s" % imageIds[i]
            print "importing from:" , dbpath
            d.read_image(dbpath, i)
            plane2D = EMNumPy.em2numpy(d)
            #print plane2D
            plane2Dlist = [plane2D]        # single plane image
        

            image = scriptUtil.createNewImage(pixelsService, rawPixelStore, re, pixelsType, gateway, plane2Dlist, newImageName, description, dataset)
            attributes = d.get_attr_dict()
            # if we know the pixel size, set it in the new image
            if "apix_x" in attributes:
                physicalSizeX = float(attributes["apix_x"])
                print "physicalSizeX" , physicalSizeX
                if "apix_y" in attributes:
                    physicalSizeY = float(attributes["apix_y"])
                    print "physicalSizeY" , physicalSizeY
                else:
                    physicalSizeY = physicalSizeX
                pixels = image.getPrimaryPixels()
                pixels.setPhysicalSizeX(rdouble(physicalSizeX))
                pixels.setPhysicalSizeY(rdouble(physicalSizeY))
                gateway.saveObject(pixels)
            
            f = open(fileName, 'w')        # will overwrite each time. 
            f.write("[GlobalMetadata]\n")
        
            # now add image attributes as "Original Metadata", sorted by key. 
            keyList = list(attributes.keys())     
            keyList.sort()
            for k in keyList:
                #print k, attributes[k]
                f.write("%s=%s\n" % (k, attributes[k]))
                if k == "ptcl_source_image":
                    print "Add link to image named: ", attributes[k]
            f.close()
        
            scriptUtil.uploadAndAttachFile(queryService, updateService, rawFileStore, image, fileName, "text/plain", None, namespace)
        # delete temp file
        os.remove(fileName)


def downloadImages(services, imageIds, local2dStack):
    """
    This method downloads the first (only?) plane of the OMERO image and saves it as a local image.
    
    @param session        The OMERO session
    @param imageId        The ID of the image to download
    @param imageName    The name of the image to write. If no path, saved in the current directory. 
    """
    # get services
    queryService = services["queryService"]
    rawPixelStore = services["rawPixelStore"]

    d = EMData()
    for imageId in imageIds:
        # get pixels with pixelsType
        query_string = "select p from Pixels p join fetch p.image i join fetch p.pixelsType pt where i.id='%d'" % imageId
        pixels = queryService.findByQuery(query_string, None)

        # get the plane
        theZ, theC, theT = (0,0,0)
        pixelsId = pixels.getId().getValue()
        bypassOriginalFile = True
        rawPixelStore.setPixelsId(pixelsId, bypassOriginalFile)
        plane2D = scriptUtil.downloadPlane(rawPixelStore, pixels, theZ, theC, theT)
        
        # convert to EMData and add to stack. See e2proc2d.py  approx line 500. 
        EMNumPy.numpy2em(plane2D, d)
        d.write_image(local2dStack, -1, EMUtil.get_image_ext_type("hdf"), False, None, EMUtil.EMDataType.EM_FLOAT, True)
    

def runCtf(session, parameterMap):
    """
    This is where the action happens.
    We get the parameters, call the command line e2ctf.py function with the additional parameters we have. 
    Then we get the output from the folder called 'particles' where the results should be, and upload these
    images into a new dataset. 
    """
    
    services["gateway"] = session.createGateway()
    services["renderingEngine"] = session.createRenderingEngine()
    services["queryService"] = session.getQueryService()
    services["pixelsService"] = session.getPixelsService()
    services["rawPixelsStore"] = session.createRawPixelsStore()
    services["updateService"] = session.getUpdateService()
    services["rawFileStore"] = session.createRawFileStore()
    
    gateway = services["gateway"]
    queryService = services["queryService"]
    
    imageIds = []
    
    dataType = commandArgs["Data_Type"]
    if dataType == "Image":
        for imageId in commandArgs["IDs"]:
            iId = long(imageId.getValue())
            imageIds.append(iId)
    else:   # Dataset
        for datasetId in commandArgs["IDs"]:
            datasetIds = []
            try:
                dId = long(datasetId.getValue())
                datasetIds.append(dId)
            except: pass
            # simply aggregate all images from the datasets
            images = gateway.getImages(omero.api.ContainerClass.Dataset, datasetIds)
            for i in images:
                imageIds.append(i.getId().getValue())
            
    if len(imageIds) == 0:
        return
        
    imageIds.sort()     # just so we process and re-import in order. 
        
    # get the project from the first image
    project = None
    imageId = imageIds[0]
    query_string = "select i from Image i join fetch i.datasetLinks idl join fetch idl.parent d join fetch d.projectLinks pl join fetch pl.parent where i.id in (%s)" % imageId
    image = queryService.findByQuery(query_string, None)
    if image:
        for link in image.iterateDatasetLinks():
            ds = link.parent
            print "Dataset", ds.name.val
            for dpLink in ds.iterateProjectLinks():
                project = dpLink.parent
                print "Project", project.name.val
                break # only use 1st Project
            break    # only use 1st Dataset
    
    
    filenames = []
    
    local2dStack = "stack.hdf"
    
    # going to write all images to a single 2D stack - processed together to give single CTF correction
    # for all particles. 
    downloadImages(services, imageIds, local2dStack)
        
    ctfCommandArgs = ["e2ctf.py"]
    ctfCommandArgs.append(local2dStack)
    ctfCommandArgs.append("--voltage=%s" % parameterMap["voltage"])
    ctfCommandArgs.append("--cs=%s" % parameterMap["cs"])
    ctfCommandArgs.append("--apix=%s" % parameterMap["apix"])
    if "oversamp" in parameterMap:
        ctfCommandArgs.append("--oversamp=%s" % parameterMap["oversamp"])
    if "ac" in parameterMap:
        ctfCommandArgs.append("--ac=%s" % parameterMap["ac"])
    if "autohp" in parameterMap:
        ctfCommandArgs.append("--autohp")
    ctfCommandArgs.append("--autofit")
    
    # use command line to run the ctf...
    ctf_command = " ".join(ctfCommandArgs)
    write_command = "e2ctf.py %s --phaseflip --wiener" % local2dStack
    
    print ctf_command
    os.system(ctf_command)
    
    print write_command
    os.system(write_command)
    
    # hopefully by this point, we have a folder called 'particles' containing a bdb for each image.
    # also have several files in the current folder, with useful info. 
    dbg = open("dbg")
    lastline = dbg.readlines()[-1]      # E.g.  5.146454	234.796172	1.624790	1.862878	3.015170	43
    cols = lastline.split("\t")
    ctfInfo = "Best DF = %s   B-factor = %s" % (cols[0], cols[1])
    uploadBdbsAsDataset(services, 'particles', imageIds, project, ctfInfo)


def runAsScript():
    """
    The main entry point of the script, as called by the client via the scripting service, passing the required parameters. 
    Calls the e2ctf.py command line, e.g. 
    e2ctf.py bdb:particles#1160_ptcls --oversamp=1 --ac=10.0 --apix=2.0 --cs=1.0 --voltage=200.0 --autohp --autofit
    
    All arguments that take a value are passed to this script as Strings, since they are only used as strings 
    in the e2ctf.py command. 
    In future, could use a 'map' parameter for users to pass additional command args and values, or even a single 
    string argument to append to the command line! 
    """
    dataTypes = [rstring('Dataset'),rstring('Image')]
    
    client = scripts.client('Ctf_Correction.py', """Use EMAN2 to calculate CTF correction on images.
See http://trac.openmicroscopy.org.uk/omero/wiki/EmPreviewFunctionality""", 
    scripts.String("Data_Type", optional=False, grouping="1",
        description="The data you want to work with.", values=dataTypes, default="Dataset"),
    scripts.List("IDs", optional=False, grouping="2",
        description="List of Dataset IDs or Image IDs").ofType(rlong(0)),
    scripts.String("voltage", description="Voltage in Kv", optional=False), 
    scripts.String("cs", description="Coefficient of Spherical abherration", optional=False),
    scripts.String("apix", description="Angstroms per pixel", optional=False),
    scripts.String("oversamp", description="optional argument to pass to ctf command. E.g. --oversamp=1"),
    scripts.String("ac", description="optional argument to pass to ctf command. E.g. --ac=10.0"),
    scripts.Bool("autohp", description="if true, add --autohp to command arg"))
    
    session = client.getSession()
    
    try:
        # process the list of args above. 
        parameterMap = {}
        for key in client.getInputKeys():
            if client.getInput(key):
                parameterMap[key] = client.getInput(key).getValue()
    
        runCtf(session, parameterMap)
    finally:
        client.closeSession()
    
    # test
if __name__ == "__main__":
    runAsScript()
    
